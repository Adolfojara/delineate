#! /usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import json
import argparse
import collections
import json
import itertools
from delineate import utility
from delineate import model

"""
Summarize DELINEATE results.
"""

__prog__ = os.path.basename(__file__)
__author__ = 'Jeet Sukumaran and Mark T. Holder'
__copyright__ = 'Copyright (C) 2019 Jeet Sukumaran and Mark T. Holder.'

def execute_newspp_probability_summarization(args,
        results_d,
        partitions_d,
        logger,
        ):
    d = summarize_conspecificity(
            args=args,
            results_d=results_d,
            partitions_d=partitions_d,
            logger=logger,
            is_calc_new_species_probability=True)
    sys.stdout.write("{}".format(d["total_marginal_probability_of_new_species"]))

def execute_conspecific_probability_summarization(
        args,
        results_d,
        partitions_d,
        logger,
        ):
    d = summarize_conspecificity(
            args=args,
            results_d=results_d,
            partitions_d=partitions_d,
            logger=logger,
            is_calc_new_species_probability=False)
    sys.stdout.write("{}".format(d["total_marginal_probability_of_conspecificity"]))

def summarize_conspecificity(
        args,
        results_d,
        partitions_d,
        logger,
        is_calc_new_species_probability,
        ):
    try:
        all_taxa_labels = results_d["lineages"]
    except KeyError:
        all_taxa_labels = set(itertools.chain.from_iterable(partitions_d[0]["species_leafsets"]))
    if is_calc_new_species_probability:
        species_constrained_lineage_map = results_d["species_constraints"]["species_constrained_lineage_map"]
    else:
        species_constrained_lineage_map = None
    if not args.quiet:
        logger.info("{} taxa defined in results file: {}".format(len(all_taxa_labels), ", ".join("'{}'".format(t) for t in sorted(all_taxa_labels))))
    total_cumulative_probability = partitions_d[-1]["constrained_cumulative_probability"]
    if not args.quiet:
        logger.info("{} partitions found in results file, with total constrained cumulative probability of {}".format(
            len(partitions_d),
            total_cumulative_probability,
            ))
    conspecific_taxa_labels = args.taxon_label
    if args.taxon_label[0] == "-":
        if not args.quiet:
            logger.info("Reading candidate taxa from standard input")
        conspecific_taxa_labels = []
        for line in sys.stdin:
            if line:
                conspecific_taxa_labels.append(line.strip())
    elif args.taxon_label[0].startswith("file://"):
        fpath = os.path.expandvars(os.path.expandargs(args.taxon_label[7:]))
        if not args.quiet:
            logger.info("Reading candidate taxa from file: '{}'".format(fpath))
        conspecific_taxa_labels = []
        with open(fpath) as taxf:
            for line in taxf:
                if line:
                    conspecific_taxa_labels.append(line.strip())
    else:
        if not args.quiet:
            logger.info("Reading candidate taxa from arguments")
        conspecific_taxa_labels = args.taxon_label
    if not conspecific_taxa_labels:
        logger.error("ERROR: Candidate conspecific taxa not defined or read in any source")
        sys.exit(1)
    conspecific_taxa_labels = sorted(set(conspecific_taxa_labels))
    if not is_calc_new_species_probability and len(conspecific_taxa_labels) == 1:
        logger.error("ERROR: At least two conspecific taxa must be defined, but only one given: '{}'".format(
            conspecific_taxa_labels[0]))
        sys.exit(1)
    if len(conspecific_taxa_labels) == 1:
        desc_noun = "taxon"
    else:
        desc_noun = "taxa"
    if not args.quiet:
        logger.info("{} candidate {} defined: {}".format(
            len(conspecific_taxa_labels),
            desc_noun,
            ", ".join("'{}'".format(t) for t in conspecific_taxa_labels)))
    not_found = []
    for ct in conspecific_taxa_labels:
        if ct not in all_taxa_labels:
            not_found.append(ct)
    if not_found:
        logger.error("ERROR: {} of {} {} not defined in results: {}".format(
            len(not_found),
            len(conspecific_taxa_labels),
            desc_noun,
            ", ".join("'{}'".format(t) for t in not_found)))
        sys.exit(1)
    conspecific_probabilities = []
    new_species_probabilities = []
    existing_species_probabilities = []
    conspecifics_in_confidence_interval = 0
    conspecifics_not_in_confidence_interval = 0
    new_spp_in_confidence_interval = 0
    new_spp_not_in_confidence_interval = 0
    for partition_idx, partition in enumerate(partitions_d):
        is_conspecific = True
        for species_label in partition["species_leafsets"]:
            species_leafset = partition["species_leafsets"][species_label]
            s = set(species_leafset)
            num_in_leafset = 0
            for ct in conspecific_taxa_labels:
                if ct in s:
                    num_in_leafset += 1
            if num_in_leafset > 0 and num_in_leafset < len(conspecific_taxa_labels):
                is_conspecific = False
                break
            elif num_in_leafset == len(conspecific_taxa_labels):
                break
        if is_conspecific:
            partition_probability = partition["constrained_probability"]
            conspecific_probabilities.append(partition_probability)
            if partition["is_in_confidence_interval"]:
                conspecifics_in_confidence_interval += 1
            else:
                conspecifics_not_in_confidence_interval += 1
            if is_calc_new_species_probability:
                if species_label in species_constrained_lineage_map:
                    existing_species_probabilities.append(partition_probability)
                else:
                    new_species_probabilities.append(partition_probability)
    total_marginal_probability_of_conspecificity = sum(conspecific_probabilities)
    if not args.quiet:
        if len(conspecific_taxa_labels) > 1:
            logger.info("{} out of {} partitions found with candidate taxa conspecific".format(
                len(conspecific_probabilities),
                len(partitions_d),
                ))
            logger.info("Marginal constrained probability of candidate taxa conspecificity: {}".format(total_marginal_probability_of_conspecificity))
        if is_calc_new_species_probability:
            total_probability_of_new_species = sum(new_species_probabilities)
            total_probability_of_existing_species = sum(existing_species_probabilities)
            logger.info("Marginal constrained probability of candidate {} being collectively *part* (i.e., non-exclusively) of a new species: {}".format(desc_noun, total_probability_of_new_species))
            logger.info("Marginal constrained probability of candidate {} being collectively *part* (i.e., non-exclusively) of a predefined species: {}".format(desc_noun, total_probability_of_existing_species))
        else:
            total_probability_of_new_species = None
            total_probability_of_existing_species = None
        if total_cumulative_probability + 1e-8 < 1.0:
            logger.warning("WARNING: cumulative constrained probability in results file is only {} --- not all partitions might have been included, and probability summarizations reported should not be considered as accurate".format(total_cumulative_probability))

    d = {
        "total_marginal_probability_of_conspecificity": total_marginal_probability_of_conspecificity,
        "total_marginal_probability_of_new_species": total_probability_of_new_species,
        "total_marginal_probability_of_existing_species": total_probability_of_new_species,
    }
    return d

def main():
    main_parser = argparse.ArgumentParser(description=__doc__)
    try:
        main_parser._optionals.title = "Program Options"
    except AttributeError:
        pass
    cmd_parser = main_parser.add_subparsers(title="Commands", dest="command")

    results_file_options = argparse.ArgumentParser(add_help=False)
    results_file_options.add_argument("-r", "--results-file",
            action="store",
            help="Path to results data (JSON).")
    taxon_specification_options = argparse.ArgumentParser(add_help=False)
    taxon_specification_options.add_argument("taxon_label",
            metavar="TAXON-LABEL",
            nargs="+",
            help="Labels of taxa. Specify '-' to read from standard input or 'file://' to read from file.",)
    output_options = argparse.ArgumentParser(add_help=False)
    output_options.add_argument("-q", "--quiet",
            action="store_true",
            default=False,
            help="Run quietly.")


    command_cli = collections.OrderedDict()
    command_cli["conspecificity"] = {
        "parents": [results_file_options, taxon_specification_options, output_options],
        "desc":
                "Given a path to a DELINEATE JSON results file, and a set"
                " of taxon labels, report the marginal probability that those"
                " taxa are conspecific.",
        "func": execute_conspecific_probability_summarization}
    command_cli["new-species"] = {
        "parents": [results_file_options, taxon_specification_options, output_options],
        "desc":
                " Given a path to a DELINEATE JSON results file, and a set"
                " of taxon labels, report the marginal probability that those"
                " taxa are conspecific AND are collectively *part* of a NEW species.",
        "func": execute_newspp_probability_summarization}
    command_parsers = collections.OrderedDict()
    for key in command_cli:
        kwargs = {}
        if command_cli[key]["parents"]:
            kwargs["parents"] = command_cli[key]["parents"]
        kwargs["help"] = command_cli[key]["desc"]
        kwargs["description"] = kwargs["help"]
        cmd_options_parser = cmd_parser.add_parser(
            key,
            **kwargs)
        cmd_options_parser.set_defaults(func=command_cli[key]["func"])
        try:
            cmd_options_parser._optionals.title = "Command Options"
            cmd_options_parser._positionals.title = "Command Targets"
        except AttributeError:
            pass
        # add_source_options(cmd_options_parser)
        # add_output_options(cmd_options_parser)
        command_parsers[key] = cmd_options_parser

    if len(sys.argv) == 1:
        msg = []
        msg.append("Please specify one of the following operations:")
        msg.append("")
        msg.append("    delineate-summarize conspecificity")
        msg.append("")
        msg.append("Or type '--help' for help:")
        msg.append("")
        msg.append("    delineate-summarize --help")
        msg.append("    delineate-summarize conspecificity --help")
        msg.append("")
        msg = "\n".join(msg)
        sys.exit(msg)

    args = main_parser.parse_args()
    # controller.is_quiet = getattr(args, "quiet", True)
    if args.results_file is None:
        sys.exit("Need to specify path to DELINEATE JSON-format results file")
    results_file = os.path.expanduser(os.path.expandvars(args.results_file))
    logger = utility.RunLogger(name="delineate-summarize",
            is_include_name=True,
            is_include_timestamp=False,
            log_to_stderr=True,
            stderr_logging_level=utility.logging.INFO,
            is_log_to_file=False,
            file_logging_level=utility.logging.INFO,
            )
    if not os.path.exists(results_file):
        logger.error("ERROR: File not found: '{}'".format(results_file))
        sys.exit(1)
    with open(results_file) as src:
        results_d = json.load(src)
    try:
        partitions_d = results_d["partitions"]
    except KeyError:
        logger.error("ERROR: 'partitions' key not found in results file.")
        sys.exit(1)
    if len(partitions_d) < 0:
        logger.error("ERROR: No data under 'partitions' key")
        sys.exit(1)

    if hasattr(args, 'func'):
        args.func(
                args=args,
                results_d=results_d,
                partitions_d=partitions_d,
                logger=logger,
                )
    else:
        pass

if __name__ == '__main__':
    main()
